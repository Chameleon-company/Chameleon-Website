{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport isString from 'lodash/isString';\nimport isNumber from 'lodash/isNumber';\nimport adjustCaretPosition from './adjustCaretPosition';\nimport conformToMask from './conformToMask';\nimport { convertMaskToPlaceholder, processCaretTraps, defaultPlaceholderChar } from './utilities';\nvar emptyString = '';\nvar strNone = 'none';\nvar strObject = 'object';\nvar isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);\nvar defer = typeof requestAnimationFrame !== 'undefined' ? requestAnimationFrame : setTimeout;\nexport default function createTextMaskInputElement(config) {\n  // Anything that we will need to keep between `update` calls, we will store in this `state` object.\n  var state = {\n    previousConformedValue: undefined,\n    previousPlaceholder: undefined\n  };\n  return {\n    state: state,\n    // `update` is called by framework components whenever they want to update the `value` of the input element.\n    // The caller can send a `rawValue` to be conformed and set on the input element. However, the default use-case\n    // is for this to be read from the `inputElement` directly.\n    update: function update(rawValue, _temp) {\n      var _pipeResults, _pipeResults2;\n\n      var _ref = _temp === void 0 ? config : _temp,\n          inputElement = _ref.inputElement,\n          providedMask = _ref.mask,\n          guide = _ref.guide,\n          pipe = _ref.pipe,\n          _ref$placeholderChar = _ref.placeholderChar,\n          placeholderChar = _ref$placeholderChar === void 0 ? defaultPlaceholderChar : _ref$placeholderChar,\n          _ref$keepCharPosition = _ref.keepCharPositions,\n          keepCharPositions = _ref$keepCharPosition === void 0 ? false : _ref$keepCharPosition,\n          _ref$showMask = _ref.showMask,\n          showMask = _ref$showMask === void 0 ? false : _ref$showMask; // if `rawValue` is `undefined`, read from the `inputElement`\n\n\n      if (typeof rawValue === 'undefined') {\n        rawValue = inputElement.value;\n      } // If `rawValue` equals `state.previousConformedValue`, we don't need to change anything. So, we return.\n      // This check is here to handle controlled framework components that repeat the `update` call on every render.\n\n\n      if (rawValue === state.previousConformedValue) {\n        return;\n      } // Text Mask accepts masks that are a combination of a `mask` and a `pipe` that work together. If such a `mask` is\n      // passed, we destructure it below, so the rest of the code can work normally as if a separate `mask` and a `pipe`\n      // were passed.\n\n\n      if (typeof providedMask === strObject && providedMask.pipe !== undefined && providedMask.mask !== undefined) {\n        pipe = providedMask.pipe;\n        providedMask = providedMask.mask;\n      } // The `placeholder` is an essential piece of how Text Mask works. For a mask like `(111)`, the placeholder would\n      // be `(___)` if the `placeholderChar` is set to `_`.\n\n\n      var placeholder; // We don't know what the mask would be yet. If it is an array, we take it as is, but if it's a function, we will\n      // have to call that function to get the mask array.\n\n      var mask; // If the provided mask is an array, we can call `convertMaskToPlaceholder` here once and we'll always have the\n      // correct `placeholder`.\n\n      if (providedMask instanceof Array) {\n        placeholder = convertMaskToPlaceholder(providedMask, placeholderChar);\n      } // In framework components that support reactivity, it's possible to turn off masking by passing\n      // `false` for `mask` after initialization. See https://github.com/text-mask/text-mask/pull/359\n\n\n      if (providedMask === false) {\n        return;\n      } // We check the provided `rawValue` before moving further.\n      // If it's something we can't work with `getSafeRawValue` will throw.\n\n\n      var safeRawValue = getSafeRawValue(rawValue); // `selectionEnd` indicates to us where the caret position is after the user has typed into the input\n\n      var currentCaretPosition = inputElement.selectionEnd; // We need to know what the `previousConformedValue` and `previousPlaceholder` is from the previous `update` call\n\n      var previousConformedValue = state.previousConformedValue,\n          previousPlaceholder = state.previousPlaceholder;\n      var caretTrapIndexes; // If the `providedMask` is a function. We need to call it at every `update` to get the `mask` array.\n      // Then we also need to get the `placeholder`\n\n      if (typeof providedMask === 'function') {\n        mask = providedMask(safeRawValue, {\n          currentCaretPosition: currentCaretPosition,\n          previousConformedValue: previousConformedValue,\n          placeholderChar: placeholderChar\n        }); // disable masking if `mask` is `false`\n\n        if (mask === false) {\n          return;\n        } // mask functions can setup caret traps to have some control over how the caret moves. We need to process\n        // the mask for any caret traps. `processCaretTraps` will remove the caret traps from the mask and return\n        // the indexes of the caret traps.\n\n\n        var _processCaretTraps = processCaretTraps(mask),\n            maskWithoutCaretTraps = _processCaretTraps.maskWithoutCaretTraps,\n            indexes = _processCaretTraps.indexes;\n\n        mask = maskWithoutCaretTraps; // The processed mask is what we're interested in\n\n        caretTrapIndexes = indexes; // And we need to store these indexes because they're needed by `adjustCaretPosition`\n\n        placeholder = convertMaskToPlaceholder(mask, placeholderChar); // If the `providedMask` is not a function, we just use it as-is.\n      } else {\n        mask = providedMask;\n      } // The following object will be passed to `conformToMask` to determine how the `rawValue` will be conformed\n\n\n      var conformToMaskConfig = {\n        previousConformedValue: previousConformedValue,\n        guide: guide,\n        placeholderChar: placeholderChar,\n        pipe: pipe,\n        placeholder: placeholder,\n        currentCaretPosition: currentCaretPosition,\n        keepCharPositions: keepCharPositions\n      }; // `conformToMask` returns `conformedValue` as part of an object for future API flexibility\n\n      var _conformToMask = conformToMask(safeRawValue, mask, conformToMaskConfig),\n          conformedValue = _conformToMask.conformedValue; // The following few lines are to support the `pipe` feature.\n\n\n      var piped = typeof pipe === 'function';\n      var pipeResults = {}; // If `pipe` is a function, we call it.\n\n      if (piped) {\n        // `pipe` receives the `conformedValue` and the configurations with which `conformToMask` was called.\n        pipeResults = pipe(conformedValue, _extends({\n          rawValue: safeRawValue\n        }, conformToMaskConfig)); // `pipeResults` should be an object. But as a convenience, we allow the pipe author to just return `false` to\n        // indicate rejection. Or return just a string when there are no piped characters.\n        // If the `pipe` returns `false` or a string, the block below turns it into an object that the rest\n        // of the code can work with.\n\n        if (pipeResults === false) {\n          // If the `pipe` rejects `conformedValue`, we use the `previousConformedValue`, and set `rejected` to `true`.\n          pipeResults = {\n            value: previousConformedValue,\n            rejected: true\n          };\n        } else if (isString(pipeResults)) {\n          pipeResults = {\n            value: pipeResults\n          };\n        }\n      } // Before we proceed, we need to know which conformed value to use, the one returned by the pipe or the one\n      // returned by `conformToMask`.\n\n\n      var finalConformedValue = piped ? (_pipeResults = pipeResults) === null || _pipeResults === void 0 ? void 0 : _pipeResults.value : conformedValue; // After determining the conformed value, we will need to know where to set\n      // the caret position. `adjustCaretPosition` will tell us.\n\n      var adjustedCaretPosition = adjustCaretPosition({\n        previousConformedValue: previousConformedValue,\n        previousPlaceholder: previousPlaceholder,\n        conformedValue: finalConformedValue,\n        placeholder: placeholder,\n        rawValue: safeRawValue,\n        currentCaretPosition: currentCaretPosition,\n        placeholderChar: placeholderChar,\n        indexesOfPipedChars: (_pipeResults2 = pipeResults) === null || _pipeResults2 === void 0 ? void 0 : _pipeResults2.indexesOfPipedChars,\n        caretTrapIndexes: caretTrapIndexes\n      }); // Text Mask sets the input value to an empty string when the condition below is set. It provides a better UX.\n\n      var inputValueShouldBeEmpty = finalConformedValue === placeholder && adjustedCaretPosition === 0;\n      var emptyValue = showMask ? placeholder : emptyString;\n      var inputElementValue = inputValueShouldBeEmpty ? emptyValue : finalConformedValue;\n      state.previousConformedValue = inputElementValue; // store value for access for next time\n\n      state.previousPlaceholder = placeholder; // In some cases, this `update` method will be repeatedly called with a raw value that has already been conformed\n      // and set to `inputElement.value`. The below check guards against needlessly readjusting the input state.\n      // See https://github.com/text-mask/text-mask/issues/231\n\n      if (inputElement.value === inputElementValue) {\n        return;\n      }\n\n      inputElement.value = inputElementValue; // set the input value\n\n      safeSetSelection(inputElement, adjustedCaretPosition); // adjust caret position\n    }\n  };\n}\n\nfunction safeSetSelection(element, selectionPosition) {\n  if (document.activeElement === element) {\n    if (isAndroid) {\n      defer(function () {\n        return element.setSelectionRange(selectionPosition, selectionPosition, strNone);\n      }, 0);\n    } else {\n      element.setSelectionRange(selectionPosition, selectionPosition, strNone);\n    }\n  }\n}\n\nfunction getSafeRawValue(inputValue) {\n  if (isString(inputValue)) {\n    return inputValue;\n  } else if (isNumber(inputValue)) {\n    return String(inputValue);\n  } else if (inputValue === undefined || inputValue === null) {\n    return emptyString;\n  } else {\n    throw new Error(\"The 'value' provided to Text Mask needs to be a string or a number. The value received was:\\n\\n \" + JSON.stringify(inputValue));\n  }\n}","map":{"version":3,"names":["_extends","isString","isNumber","adjustCaretPosition","conformToMask","convertMaskToPlaceholder","processCaretTraps","defaultPlaceholderChar","emptyString","strNone","strObject","isAndroid","navigator","test","userAgent","defer","requestAnimationFrame","setTimeout","createTextMaskInputElement","config","state","previousConformedValue","undefined","previousPlaceholder","update","rawValue","_temp","_pipeResults","_pipeResults2","_ref","inputElement","providedMask","mask","guide","pipe","_ref$placeholderChar","placeholderChar","_ref$keepCharPosition","keepCharPositions","_ref$showMask","showMask","value","placeholder","Array","safeRawValue","getSafeRawValue","currentCaretPosition","selectionEnd","caretTrapIndexes","_processCaretTraps","maskWithoutCaretTraps","indexes","conformToMaskConfig","_conformToMask","conformedValue","piped","pipeResults","rejected","finalConformedValue","adjustedCaretPosition","indexesOfPipedChars","inputValueShouldBeEmpty","emptyValue","inputElementValue","safeSetSelection","element","selectionPosition","document","activeElement","setSelectionRange","inputValue","String","Error","JSON","stringify"],"sources":["C:/Users/61420/Desktop/chameleon-website/node_modules/rsuite/esm/MaskedInput/createTextMaskInputElement.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport isString from 'lodash/isString';\nimport isNumber from 'lodash/isNumber';\nimport adjustCaretPosition from './adjustCaretPosition';\nimport conformToMask from './conformToMask';\nimport { convertMaskToPlaceholder, processCaretTraps, defaultPlaceholderChar } from './utilities';\nvar emptyString = '';\nvar strNone = 'none';\nvar strObject = 'object';\nvar isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);\nvar defer = typeof requestAnimationFrame !== 'undefined' ? requestAnimationFrame : setTimeout;\nexport default function createTextMaskInputElement(config) {\n  // Anything that we will need to keep between `update` calls, we will store in this `state` object.\n  var state = {\n    previousConformedValue: undefined,\n    previousPlaceholder: undefined\n  };\n  return {\n    state: state,\n    // `update` is called by framework components whenever they want to update the `value` of the input element.\n    // The caller can send a `rawValue` to be conformed and set on the input element. However, the default use-case\n    // is for this to be read from the `inputElement` directly.\n    update: function update(rawValue, _temp) {\n      var _pipeResults, _pipeResults2;\n\n      var _ref = _temp === void 0 ? config : _temp,\n          inputElement = _ref.inputElement,\n          providedMask = _ref.mask,\n          guide = _ref.guide,\n          pipe = _ref.pipe,\n          _ref$placeholderChar = _ref.placeholderChar,\n          placeholderChar = _ref$placeholderChar === void 0 ? defaultPlaceholderChar : _ref$placeholderChar,\n          _ref$keepCharPosition = _ref.keepCharPositions,\n          keepCharPositions = _ref$keepCharPosition === void 0 ? false : _ref$keepCharPosition,\n          _ref$showMask = _ref.showMask,\n          showMask = _ref$showMask === void 0 ? false : _ref$showMask;\n\n      // if `rawValue` is `undefined`, read from the `inputElement`\n      if (typeof rawValue === 'undefined') {\n        rawValue = inputElement.value;\n      } // If `rawValue` equals `state.previousConformedValue`, we don't need to change anything. So, we return.\n      // This check is here to handle controlled framework components that repeat the `update` call on every render.\n\n\n      if (rawValue === state.previousConformedValue) {\n        return;\n      } // Text Mask accepts masks that are a combination of a `mask` and a `pipe` that work together. If such a `mask` is\n      // passed, we destructure it below, so the rest of the code can work normally as if a separate `mask` and a `pipe`\n      // were passed.\n\n\n      if (typeof providedMask === strObject && providedMask.pipe !== undefined && providedMask.mask !== undefined) {\n        pipe = providedMask.pipe;\n        providedMask = providedMask.mask;\n      } // The `placeholder` is an essential piece of how Text Mask works. For a mask like `(111)`, the placeholder would\n      // be `(___)` if the `placeholderChar` is set to `_`.\n\n\n      var placeholder; // We don't know what the mask would be yet. If it is an array, we take it as is, but if it's a function, we will\n      // have to call that function to get the mask array.\n\n      var mask; // If the provided mask is an array, we can call `convertMaskToPlaceholder` here once and we'll always have the\n      // correct `placeholder`.\n\n      if (providedMask instanceof Array) {\n        placeholder = convertMaskToPlaceholder(providedMask, placeholderChar);\n      } // In framework components that support reactivity, it's possible to turn off masking by passing\n      // `false` for `mask` after initialization. See https://github.com/text-mask/text-mask/pull/359\n\n\n      if (providedMask === false) {\n        return;\n      } // We check the provided `rawValue` before moving further.\n      // If it's something we can't work with `getSafeRawValue` will throw.\n\n\n      var safeRawValue = getSafeRawValue(rawValue); // `selectionEnd` indicates to us where the caret position is after the user has typed into the input\n\n      var currentCaretPosition = inputElement.selectionEnd; // We need to know what the `previousConformedValue` and `previousPlaceholder` is from the previous `update` call\n\n      var previousConformedValue = state.previousConformedValue,\n          previousPlaceholder = state.previousPlaceholder;\n      var caretTrapIndexes; // If the `providedMask` is a function. We need to call it at every `update` to get the `mask` array.\n      // Then we also need to get the `placeholder`\n\n      if (typeof providedMask === 'function') {\n        mask = providedMask(safeRawValue, {\n          currentCaretPosition: currentCaretPosition,\n          previousConformedValue: previousConformedValue,\n          placeholderChar: placeholderChar\n        }); // disable masking if `mask` is `false`\n\n        if (mask === false) {\n          return;\n        } // mask functions can setup caret traps to have some control over how the caret moves. We need to process\n        // the mask for any caret traps. `processCaretTraps` will remove the caret traps from the mask and return\n        // the indexes of the caret traps.\n\n\n        var _processCaretTraps = processCaretTraps(mask),\n            maskWithoutCaretTraps = _processCaretTraps.maskWithoutCaretTraps,\n            indexes = _processCaretTraps.indexes;\n\n        mask = maskWithoutCaretTraps; // The processed mask is what we're interested in\n\n        caretTrapIndexes = indexes; // And we need to store these indexes because they're needed by `adjustCaretPosition`\n\n        placeholder = convertMaskToPlaceholder(mask, placeholderChar); // If the `providedMask` is not a function, we just use it as-is.\n      } else {\n        mask = providedMask;\n      } // The following object will be passed to `conformToMask` to determine how the `rawValue` will be conformed\n\n\n      var conformToMaskConfig = {\n        previousConformedValue: previousConformedValue,\n        guide: guide,\n        placeholderChar: placeholderChar,\n        pipe: pipe,\n        placeholder: placeholder,\n        currentCaretPosition: currentCaretPosition,\n        keepCharPositions: keepCharPositions\n      }; // `conformToMask` returns `conformedValue` as part of an object for future API flexibility\n\n      var _conformToMask = conformToMask(safeRawValue, mask, conformToMaskConfig),\n          conformedValue = _conformToMask.conformedValue; // The following few lines are to support the `pipe` feature.\n\n\n      var piped = typeof pipe === 'function';\n      var pipeResults = {}; // If `pipe` is a function, we call it.\n\n      if (piped) {\n        // `pipe` receives the `conformedValue` and the configurations with which `conformToMask` was called.\n        pipeResults = pipe(conformedValue, _extends({\n          rawValue: safeRawValue\n        }, conformToMaskConfig)); // `pipeResults` should be an object. But as a convenience, we allow the pipe author to just return `false` to\n        // indicate rejection. Or return just a string when there are no piped characters.\n        // If the `pipe` returns `false` or a string, the block below turns it into an object that the rest\n        // of the code can work with.\n\n        if (pipeResults === false) {\n          // If the `pipe` rejects `conformedValue`, we use the `previousConformedValue`, and set `rejected` to `true`.\n          pipeResults = {\n            value: previousConformedValue,\n            rejected: true\n          };\n        } else if (isString(pipeResults)) {\n          pipeResults = {\n            value: pipeResults\n          };\n        }\n      } // Before we proceed, we need to know which conformed value to use, the one returned by the pipe or the one\n      // returned by `conformToMask`.\n\n\n      var finalConformedValue = piped ? (_pipeResults = pipeResults) === null || _pipeResults === void 0 ? void 0 : _pipeResults.value : conformedValue; // After determining the conformed value, we will need to know where to set\n      // the caret position. `adjustCaretPosition` will tell us.\n\n      var adjustedCaretPosition = adjustCaretPosition({\n        previousConformedValue: previousConformedValue,\n        previousPlaceholder: previousPlaceholder,\n        conformedValue: finalConformedValue,\n        placeholder: placeholder,\n        rawValue: safeRawValue,\n        currentCaretPosition: currentCaretPosition,\n        placeholderChar: placeholderChar,\n        indexesOfPipedChars: (_pipeResults2 = pipeResults) === null || _pipeResults2 === void 0 ? void 0 : _pipeResults2.indexesOfPipedChars,\n        caretTrapIndexes: caretTrapIndexes\n      }); // Text Mask sets the input value to an empty string when the condition below is set. It provides a better UX.\n\n      var inputValueShouldBeEmpty = finalConformedValue === placeholder && adjustedCaretPosition === 0;\n      var emptyValue = showMask ? placeholder : emptyString;\n      var inputElementValue = inputValueShouldBeEmpty ? emptyValue : finalConformedValue;\n      state.previousConformedValue = inputElementValue; // store value for access for next time\n\n      state.previousPlaceholder = placeholder; // In some cases, this `update` method will be repeatedly called with a raw value that has already been conformed\n      // and set to `inputElement.value`. The below check guards against needlessly readjusting the input state.\n      // See https://github.com/text-mask/text-mask/issues/231\n\n      if (inputElement.value === inputElementValue) {\n        return;\n      }\n\n      inputElement.value = inputElementValue; // set the input value\n\n      safeSetSelection(inputElement, adjustedCaretPosition); // adjust caret position\n    }\n  };\n}\n\nfunction safeSetSelection(element, selectionPosition) {\n  if (document.activeElement === element) {\n    if (isAndroid) {\n      defer(function () {\n        return element.setSelectionRange(selectionPosition, selectionPosition, strNone);\n      }, 0);\n    } else {\n      element.setSelectionRange(selectionPosition, selectionPosition, strNone);\n    }\n  }\n}\n\nfunction getSafeRawValue(inputValue) {\n  if (isString(inputValue)) {\n    return inputValue;\n  } else if (isNumber(inputValue)) {\n    return String(inputValue);\n  } else if (inputValue === undefined || inputValue === null) {\n    return emptyString;\n  } else {\n    throw new Error(\"The 'value' provided to Text Mask needs to be a string or a number. The value received was:\\n\\n \" + JSON.stringify(inputValue));\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}