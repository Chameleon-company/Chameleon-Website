{"ast":null,"code":"import { convertMaskToPlaceholder, processCaretTraps, defaultPlaceholderChar } from './utilities';\nexport function isArray(value) {\n  return Array.isArray && Array.isArray(value) || value instanceof Array;\n}\nexport default function conformToMask(rawValue, mask, config) {\n  if (rawValue === void 0) {\n    rawValue = '';\n  }\n\n  if (mask === void 0) {\n    mask = [];\n  }\n\n  if (config === void 0) {\n    config = {};\n  }\n\n  if (!isArray(mask)) {\n    // If someone passes a function as the mask property, we should call the\n    // function to get the mask array - Normally this is handled by the\n    // `createTextMaskInputElement:update` function - this allows mask functions\n    // to be used directly with `conformToMask`\n    if (typeof mask === 'function') {\n      // call the mask function to get the mask array\n      mask = mask(rawValue, config); // mask functions can setup caret traps to have some control over how the caret moves. We need to process\n      // the mask for any caret traps. `processCaretTraps` will remove the caret traps from the mask\n\n      mask = processCaretTraps(mask).maskWithoutCaretTraps;\n    } else {\n      throw new Error('Text-mask:conformToMask; The mask property must be an array.');\n    }\n  } // These configurations tell us how to conform the mask\n\n\n  var _config = config,\n      _config$guide = _config.guide,\n      guide = _config$guide === void 0 ? true : _config$guide,\n      _config$previousConfo = _config.previousConformedValue,\n      previousConformedValue = _config$previousConfo === void 0 ? '' : _config$previousConfo,\n      _config$placeholderCh = _config.placeholderChar,\n      placeholderChar = _config$placeholderCh === void 0 ? defaultPlaceholderChar : _config$placeholderCh,\n      _config$placeholder = _config.placeholder,\n      placeholder = _config$placeholder === void 0 ? convertMaskToPlaceholder(mask, placeholderChar) : _config$placeholder,\n      _config$currentCaretP = _config.currentCaretPosition,\n      currentCaretPosition = _config$currentCaretP === void 0 ? 0 : _config$currentCaretP,\n      keepCharPositions = _config.keepCharPositions; // The configs below indicate that the user wants the algorithm to work in *no guide* mode\n\n  var suppressGuide = guide === false && previousConformedValue !== undefined; // Calculate lengths once for performance\n\n  var rawValueLength = rawValue.length;\n  var previousConformedValueLength = previousConformedValue.length;\n  var placeholderLength = placeholder.length;\n  var maskLength = mask.length; // This tells us the number of edited characters and the direction in which they were edited (+/-)\n\n  var editDistance = rawValueLength - previousConformedValueLength; // In *no guide* mode, we need to know if the user is trying to add a character or not\n\n  var isAddition = editDistance > 0; // Tells us the index of the first change. For (438) 394-4938 to (38) 394-4938, that would be 1\n\n  var indexOfFirstChange = currentCaretPosition + (isAddition ? -editDistance : 0); // We're also gonna need the index of last change, which we can derive as follows...\n\n  var indexOfLastChange = indexOfFirstChange + Math.abs(editDistance); // If `conformToMask` is configured to keep character positions, that is, for mask 111, previous value\n  // _2_ and raw value 3_2_, the new conformed value should be 32_, not 3_2 (default behavior). That's in the case of\n  // addition. And in the case of deletion, previous value _23, raw value _3, the new conformed string should be\n  // __3, not _3_ (default behavior)\n  //\n  // The next block of logic handles keeping character positions for the case of deletion. (Keeping\n  // character positions for the case of addition is further down since it is handled differently.)\n  // To do this, we want to compensate for all characters that were deleted\n\n  if (keepCharPositions === true && !isAddition) {\n    // We will be storing the new placeholder characters in this variable.\n    var compensatingPlaceholderChars = ''; // For every character that was deleted from a placeholder position, we add a placeholder char\n\n    for (var i = indexOfFirstChange; i < indexOfLastChange; i++) {\n      if (placeholder[i] === placeholderChar) {\n        compensatingPlaceholderChars += placeholderChar;\n      }\n    } // Now we trick our algorithm by modifying the raw value to make it contain additional placeholder characters\n    // That way when the we start laying the characters again on the mask, it will keep the non-deleted characters\n    // in their positions.\n\n\n    rawValue = rawValue.slice(0, indexOfFirstChange) + compensatingPlaceholderChars + rawValue.slice(indexOfFirstChange, rawValueLength);\n  } // Convert `rawValue` string to an array, and mark characters based on whether they are newly added or have\n  // existed in the previous conformed value. Identifying new and old characters is needed for `conformToMask`\n  // to work if it is configured to keep character positions.\n\n\n  var rawValueArr = rawValue.split('').map(function (char, i) {\n    return {\n      char: char,\n      isNew: i >= indexOfFirstChange && i < indexOfLastChange\n    };\n  }); // The loop below removes masking characters from user input. For example, for mask\n  // `00 (111)`, the placeholder would be `00 (___)`. If user input is `00 (234)`, the loop below\n  // would remove all characters but `234` from the `rawValueArr`. The rest of the algorithm\n  // then would lay `234` on top of the available placeholder positions in the mask.\n\n  for (var _i = rawValueLength - 1; _i >= 0; _i--) {\n    var char = rawValueArr[_i].char;\n\n    if (char !== placeholderChar) {\n      var shouldOffset = _i >= indexOfFirstChange && previousConformedValueLength === maskLength;\n\n      if (char === placeholder[shouldOffset ? _i - editDistance : _i]) {\n        rawValueArr.splice(_i, 1);\n      }\n    }\n  } // This is the variable that we will be filling with characters as we figure them out\n  // in the algorithm below\n\n\n  var conformedValue = '';\n  var someCharsRejected = false; // Ok, so first we loop through the placeholder looking for placeholder characters to fill up.\n\n  placeholderLoop: for (var _i2 = 0; _i2 < placeholderLength; _i2++) {\n    var charInPlaceholder = placeholder[_i2]; // We see one. Let's find out what we can put in it.\n\n    if (charInPlaceholder === placeholderChar) {\n      // But before that, do we actually have any user characters that need a place?\n      if (rawValueArr.length > 0) {\n        // We will keep chipping away at user input until either we run out of characters\n        // or we find at least one character that we can map.\n        while (rawValueArr.length > 0) {\n          // Let's retrieve the first user character in the queue of characters we have left\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          var _ref = rawValueArr.shift(),\n              rawValueChar = _ref.char,\n              isNew = _ref.isNew; // If the character we got from the user input is a placeholder character (which happens\n          // regularly because user input could be something like (540) 90_-____, which includes\n          // a bunch of `_` which are placeholder characters) and we are not in *no guide* mode,\n          // then we map this placeholder character to the current spot in the placeholder\n\n\n          if (rawValueChar === placeholderChar && suppressGuide !== true) {\n            conformedValue += placeholderChar; // And we go to find the next placeholder character that needs filling\n\n            continue placeholderLoop; // Else if, the character we got from the user input is not a placeholder, let's see\n            // if the current position in the mask can accept it.\n          } else if (mask[_i2].test(rawValueChar)) {\n            // we map the character differently based on whether we are keeping character positions or not.\n            // If any of the conditions below are met, we simply map the raw value character to the\n            // placeholder position.\n            if (keepCharPositions !== true || isNew === false || previousConformedValue === '' || guide === false || !isAddition) {\n              conformedValue += rawValueChar;\n            } else {\n              // We enter this block of code if we are trying to keep character positions and none of the conditions\n              // above is met. In this case, we need to see if there's an available spot for the raw value character\n              // to be mapped to. If we couldn't find a spot, we will discard the character.\n              //\n              // For example, for mask `1111`, previous conformed value `_2__`, raw value `942_2__`. We can map the\n              // `9`, to the first available placeholder position, but then, there are no more spots available for the\n              // `4` and `2`. So, we discard them and end up with a conformed value of `92__`.\n              var rawValueArrLength = rawValueArr.length;\n              var indexOfNextAvailablePlaceholderChar = null; // Let's loop through the remaining raw value characters. We are looking for either a suitable spot, ie,\n              // a placeholder character or a non-suitable spot, ie, a non-placeholder character that is not new.\n              // If we see a suitable spot first, we store its position and exit the loop. If we see a non-suitable\n              // spot first, we exit the loop and our `indexOfNextAvailablePlaceholderChar` will stay as `null`.\n\n              for (var _i3 = 0; _i3 < rawValueArrLength; _i3++) {\n                var charData = rawValueArr[_i3];\n\n                if (charData.char !== placeholderChar && charData.isNew === false) {\n                  break;\n                }\n\n                if (charData.char === placeholderChar) {\n                  indexOfNextAvailablePlaceholderChar = _i3;\n                  break;\n                }\n              } // If `indexOfNextAvailablePlaceholderChar` is not `null`, that means the character is not blocked.\n              // We can map it. And to keep the character positions, we remove the placeholder character\n              // from the remaining characters\n\n\n              if (indexOfNextAvailablePlaceholderChar !== null) {\n                conformedValue += rawValueChar;\n                rawValueArr.splice(indexOfNextAvailablePlaceholderChar, 1); // If `indexOfNextAvailablePlaceholderChar` is `null`, that means the character is blocked. We have to\n                // discard it.\n              } else {\n                _i2--;\n              }\n            } // Since we've mapped this placeholder position. We move on to the next one.\n\n\n            continue placeholderLoop;\n          } else {\n            someCharsRejected = true;\n          }\n        }\n      } // We reach this point when we've mapped all the user input characters to placeholder\n      // positions in the mask. In *guide* mode, we append the left over characters in the\n      // placeholder to the `conformedString`, but in *no guide* mode, we don't wanna do that.\n      //\n      // That is, for mask `(111)` and user input `2`, we want to return `(2`, not `(2__)`.\n\n\n      if (suppressGuide === false) {\n        conformedValue += placeholder.substr(_i2, placeholderLength);\n      } // And we break\n\n\n      break; // Else, the charInPlaceholder is not a placeholderChar. That is, we cannot fill it\n      // with user input. So we just map it to the final output\n    } else {\n      conformedValue += charInPlaceholder;\n    }\n  } // The following logic is needed to deal with the case of deletion in *no guide* mode.\n  //\n  // Consider the silly mask `(111) /// 1`. What if user tries to delete the last placeholder\n  // position? Something like `(589) /// `. We want to conform that to `(589`. Not `(589) /// `.\n  // That's why the logic below finds the last filled placeholder character, and removes everything\n  // from that point on.\n\n\n  if (suppressGuide && isAddition === false) {\n    var indexOfLastFilledPlaceholderChar = null; // Find the last filled placeholder position and substring from there\n\n    for (var _i4 = 0; _i4 < conformedValue.length; _i4++) {\n      if (placeholder[_i4] === placeholderChar) {\n        indexOfLastFilledPlaceholderChar = _i4;\n      }\n    }\n\n    if (indexOfLastFilledPlaceholderChar !== null) {\n      // We substring from the beginning until the position after the last filled placeholder char.\n      conformedValue = conformedValue.substr(0, indexOfLastFilledPlaceholderChar + 1);\n    } else {\n      // If we couldn't find `indexOfLastFilledPlaceholderChar` that means the user deleted\n      // the first character in the mask. So we return an empty string.\n      conformedValue = '';\n    }\n  }\n\n  return {\n    conformedValue: conformedValue,\n    meta: {\n      someCharsRejected: someCharsRejected\n    }\n  };\n}","map":{"version":3,"names":["convertMaskToPlaceholder","processCaretTraps","defaultPlaceholderChar","isArray","value","Array","conformToMask","rawValue","mask","config","maskWithoutCaretTraps","Error","_config","_config$guide","guide","_config$previousConfo","previousConformedValue","_config$placeholderCh","placeholderChar","_config$placeholder","placeholder","_config$currentCaretP","currentCaretPosition","keepCharPositions","suppressGuide","undefined","rawValueLength","length","previousConformedValueLength","placeholderLength","maskLength","editDistance","isAddition","indexOfFirstChange","indexOfLastChange","Math","abs","compensatingPlaceholderChars","i","slice","rawValueArr","split","map","char","isNew","_i","shouldOffset","splice","conformedValue","someCharsRejected","placeholderLoop","_i2","charInPlaceholder","_ref","shift","rawValueChar","test","rawValueArrLength","indexOfNextAvailablePlaceholderChar","_i3","charData","substr","indexOfLastFilledPlaceholderChar","_i4","meta"],"sources":["C:/Users/jaink/OneDrive/Desktop/New folder (4)/chameleon-website/node_modules/rsuite/esm/MaskedInput/conformToMask.js"],"sourcesContent":["import { convertMaskToPlaceholder, processCaretTraps, defaultPlaceholderChar } from './utilities';\nexport function isArray(value) {\n  return Array.isArray && Array.isArray(value) || value instanceof Array;\n}\nexport default function conformToMask(rawValue, mask, config) {\n  if (rawValue === void 0) {\n    rawValue = '';\n  }\n\n  if (mask === void 0) {\n    mask = [];\n  }\n\n  if (config === void 0) {\n    config = {};\n  }\n\n  if (!isArray(mask)) {\n    // If someone passes a function as the mask property, we should call the\n    // function to get the mask array - Normally this is handled by the\n    // `createTextMaskInputElement:update` function - this allows mask functions\n    // to be used directly with `conformToMask`\n    if (typeof mask === 'function') {\n      // call the mask function to get the mask array\n      mask = mask(rawValue, config); // mask functions can setup caret traps to have some control over how the caret moves. We need to process\n      // the mask for any caret traps. `processCaretTraps` will remove the caret traps from the mask\n\n      mask = processCaretTraps(mask).maskWithoutCaretTraps;\n    } else {\n      throw new Error('Text-mask:conformToMask; The mask property must be an array.');\n    }\n  } // These configurations tell us how to conform the mask\n\n\n  var _config = config,\n      _config$guide = _config.guide,\n      guide = _config$guide === void 0 ? true : _config$guide,\n      _config$previousConfo = _config.previousConformedValue,\n      previousConformedValue = _config$previousConfo === void 0 ? '' : _config$previousConfo,\n      _config$placeholderCh = _config.placeholderChar,\n      placeholderChar = _config$placeholderCh === void 0 ? defaultPlaceholderChar : _config$placeholderCh,\n      _config$placeholder = _config.placeholder,\n      placeholder = _config$placeholder === void 0 ? convertMaskToPlaceholder(mask, placeholderChar) : _config$placeholder,\n      _config$currentCaretP = _config.currentCaretPosition,\n      currentCaretPosition = _config$currentCaretP === void 0 ? 0 : _config$currentCaretP,\n      keepCharPositions = _config.keepCharPositions; // The configs below indicate that the user wants the algorithm to work in *no guide* mode\n\n  var suppressGuide = guide === false && previousConformedValue !== undefined; // Calculate lengths once for performance\n\n  var rawValueLength = rawValue.length;\n  var previousConformedValueLength = previousConformedValue.length;\n  var placeholderLength = placeholder.length;\n  var maskLength = mask.length; // This tells us the number of edited characters and the direction in which they were edited (+/-)\n\n  var editDistance = rawValueLength - previousConformedValueLength; // In *no guide* mode, we need to know if the user is trying to add a character or not\n\n  var isAddition = editDistance > 0; // Tells us the index of the first change. For (438) 394-4938 to (38) 394-4938, that would be 1\n\n  var indexOfFirstChange = currentCaretPosition + (isAddition ? -editDistance : 0); // We're also gonna need the index of last change, which we can derive as follows...\n\n  var indexOfLastChange = indexOfFirstChange + Math.abs(editDistance); // If `conformToMask` is configured to keep character positions, that is, for mask 111, previous value\n  // _2_ and raw value 3_2_, the new conformed value should be 32_, not 3_2 (default behavior). That's in the case of\n  // addition. And in the case of deletion, previous value _23, raw value _3, the new conformed string should be\n  // __3, not _3_ (default behavior)\n  //\n  // The next block of logic handles keeping character positions for the case of deletion. (Keeping\n  // character positions for the case of addition is further down since it is handled differently.)\n  // To do this, we want to compensate for all characters that were deleted\n\n  if (keepCharPositions === true && !isAddition) {\n    // We will be storing the new placeholder characters in this variable.\n    var compensatingPlaceholderChars = ''; // For every character that was deleted from a placeholder position, we add a placeholder char\n\n    for (var i = indexOfFirstChange; i < indexOfLastChange; i++) {\n      if (placeholder[i] === placeholderChar) {\n        compensatingPlaceholderChars += placeholderChar;\n      }\n    } // Now we trick our algorithm by modifying the raw value to make it contain additional placeholder characters\n    // That way when the we start laying the characters again on the mask, it will keep the non-deleted characters\n    // in their positions.\n\n\n    rawValue = rawValue.slice(0, indexOfFirstChange) + compensatingPlaceholderChars + rawValue.slice(indexOfFirstChange, rawValueLength);\n  } // Convert `rawValue` string to an array, and mark characters based on whether they are newly added or have\n  // existed in the previous conformed value. Identifying new and old characters is needed for `conformToMask`\n  // to work if it is configured to keep character positions.\n\n\n  var rawValueArr = rawValue.split('').map(function (char, i) {\n    return {\n      char: char,\n      isNew: i >= indexOfFirstChange && i < indexOfLastChange\n    };\n  }); // The loop below removes masking characters from user input. For example, for mask\n  // `00 (111)`, the placeholder would be `00 (___)`. If user input is `00 (234)`, the loop below\n  // would remove all characters but `234` from the `rawValueArr`. The rest of the algorithm\n  // then would lay `234` on top of the available placeholder positions in the mask.\n\n  for (var _i = rawValueLength - 1; _i >= 0; _i--) {\n    var char = rawValueArr[_i].char;\n\n    if (char !== placeholderChar) {\n      var shouldOffset = _i >= indexOfFirstChange && previousConformedValueLength === maskLength;\n\n      if (char === placeholder[shouldOffset ? _i - editDistance : _i]) {\n        rawValueArr.splice(_i, 1);\n      }\n    }\n  } // This is the variable that we will be filling with characters as we figure them out\n  // in the algorithm below\n\n\n  var conformedValue = '';\n  var someCharsRejected = false; // Ok, so first we loop through the placeholder looking for placeholder characters to fill up.\n\n  placeholderLoop: for (var _i2 = 0; _i2 < placeholderLength; _i2++) {\n    var charInPlaceholder = placeholder[_i2]; // We see one. Let's find out what we can put in it.\n\n    if (charInPlaceholder === placeholderChar) {\n      // But before that, do we actually have any user characters that need a place?\n      if (rawValueArr.length > 0) {\n        // We will keep chipping away at user input until either we run out of characters\n        // or we find at least one character that we can map.\n        while (rawValueArr.length > 0) {\n          // Let's retrieve the first user character in the queue of characters we have left\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          var _ref = rawValueArr.shift(),\n              rawValueChar = _ref.char,\n              isNew = _ref.isNew; // If the character we got from the user input is a placeholder character (which happens\n          // regularly because user input could be something like (540) 90_-____, which includes\n          // a bunch of `_` which are placeholder characters) and we are not in *no guide* mode,\n          // then we map this placeholder character to the current spot in the placeholder\n\n\n          if (rawValueChar === placeholderChar && suppressGuide !== true) {\n            conformedValue += placeholderChar; // And we go to find the next placeholder character that needs filling\n\n            continue placeholderLoop; // Else if, the character we got from the user input is not a placeholder, let's see\n            // if the current position in the mask can accept it.\n          } else if (mask[_i2].test(rawValueChar)) {\n            // we map the character differently based on whether we are keeping character positions or not.\n            // If any of the conditions below are met, we simply map the raw value character to the\n            // placeholder position.\n            if (keepCharPositions !== true || isNew === false || previousConformedValue === '' || guide === false || !isAddition) {\n              conformedValue += rawValueChar;\n            } else {\n              // We enter this block of code if we are trying to keep character positions and none of the conditions\n              // above is met. In this case, we need to see if there's an available spot for the raw value character\n              // to be mapped to. If we couldn't find a spot, we will discard the character.\n              //\n              // For example, for mask `1111`, previous conformed value `_2__`, raw value `942_2__`. We can map the\n              // `9`, to the first available placeholder position, but then, there are no more spots available for the\n              // `4` and `2`. So, we discard them and end up with a conformed value of `92__`.\n              var rawValueArrLength = rawValueArr.length;\n              var indexOfNextAvailablePlaceholderChar = null; // Let's loop through the remaining raw value characters. We are looking for either a suitable spot, ie,\n              // a placeholder character or a non-suitable spot, ie, a non-placeholder character that is not new.\n              // If we see a suitable spot first, we store its position and exit the loop. If we see a non-suitable\n              // spot first, we exit the loop and our `indexOfNextAvailablePlaceholderChar` will stay as `null`.\n\n              for (var _i3 = 0; _i3 < rawValueArrLength; _i3++) {\n                var charData = rawValueArr[_i3];\n\n                if (charData.char !== placeholderChar && charData.isNew === false) {\n                  break;\n                }\n\n                if (charData.char === placeholderChar) {\n                  indexOfNextAvailablePlaceholderChar = _i3;\n                  break;\n                }\n              } // If `indexOfNextAvailablePlaceholderChar` is not `null`, that means the character is not blocked.\n              // We can map it. And to keep the character positions, we remove the placeholder character\n              // from the remaining characters\n\n\n              if (indexOfNextAvailablePlaceholderChar !== null) {\n                conformedValue += rawValueChar;\n                rawValueArr.splice(indexOfNextAvailablePlaceholderChar, 1); // If `indexOfNextAvailablePlaceholderChar` is `null`, that means the character is blocked. We have to\n                // discard it.\n              } else {\n                _i2--;\n              }\n            } // Since we've mapped this placeholder position. We move on to the next one.\n\n\n            continue placeholderLoop;\n          } else {\n            someCharsRejected = true;\n          }\n        }\n      } // We reach this point when we've mapped all the user input characters to placeholder\n      // positions in the mask. In *guide* mode, we append the left over characters in the\n      // placeholder to the `conformedString`, but in *no guide* mode, we don't wanna do that.\n      //\n      // That is, for mask `(111)` and user input `2`, we want to return `(2`, not `(2__)`.\n\n\n      if (suppressGuide === false) {\n        conformedValue += placeholder.substr(_i2, placeholderLength);\n      } // And we break\n\n\n      break; // Else, the charInPlaceholder is not a placeholderChar. That is, we cannot fill it\n      // with user input. So we just map it to the final output\n    } else {\n      conformedValue += charInPlaceholder;\n    }\n  } // The following logic is needed to deal with the case of deletion in *no guide* mode.\n  //\n  // Consider the silly mask `(111) /// 1`. What if user tries to delete the last placeholder\n  // position? Something like `(589) /// `. We want to conform that to `(589`. Not `(589) /// `.\n  // That's why the logic below finds the last filled placeholder character, and removes everything\n  // from that point on.\n\n\n  if (suppressGuide && isAddition === false) {\n    var indexOfLastFilledPlaceholderChar = null; // Find the last filled placeholder position and substring from there\n\n    for (var _i4 = 0; _i4 < conformedValue.length; _i4++) {\n      if (placeholder[_i4] === placeholderChar) {\n        indexOfLastFilledPlaceholderChar = _i4;\n      }\n    }\n\n    if (indexOfLastFilledPlaceholderChar !== null) {\n      // We substring from the beginning until the position after the last filled placeholder char.\n      conformedValue = conformedValue.substr(0, indexOfLastFilledPlaceholderChar + 1);\n    } else {\n      // If we couldn't find `indexOfLastFilledPlaceholderChar` that means the user deleted\n      // the first character in the mask. So we return an empty string.\n      conformedValue = '';\n    }\n  }\n\n  return {\n    conformedValue: conformedValue,\n    meta: {\n      someCharsRejected: someCharsRejected\n    }\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}