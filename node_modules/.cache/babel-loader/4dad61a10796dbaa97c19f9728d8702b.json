{"ast":null,"code":"/**\n * interactive elements should be skiped\n * */\nvar INTERACTIVE_ELEMENTS = ['A', 'BUTTON', 'INPUT', 'OPTION', 'TEXTAREA', 'SELECT'];\nexport function isContainInteractiveElement(targetNode) {\n  return INTERACTIVE_ELEMENTS.includes(targetNode.tagName) || targetNode.contentEditable === 'true';\n}\nexport function setInlineStyles(node, styles) {\n  if (node !== null && styles !== null) {\n    for (var _i = 0, _Object$entries = Object.entries(styles); _i < _Object$entries.length; _i++) {\n      var _Object$entries$_i = _Object$entries[_i],\n          key = _Object$entries$_i[0],\n          value = _Object$entries$_i[1];\n      node.style[key] = value;\n    }\n  }\n}\nexport function setTranslate3d(node, translate) {\n  setInlineStyles(node, {\n    transform: translate ? \"translate3d(\" + translate.x + \"px,\" + translate.y + \"px,0)\" : ''\n  });\n}\nexport function setTransitionDuration(node, duration) {\n  setInlineStyles(node, {\n    transitionDuration: duration ? duration + \"ms\" : ''\n  });\n}\n/**\n * find closest target node from source node\n * */\n\nexport function closestNode(sourceNode, judge) {\n  var currentNode = sourceNode;\n\n  while (currentNode) {\n    if (judge(currentNode)) {\n      return currentNode;\n    }\n\n    currentNode = currentNode.parentNode;\n  }\n\n  return null;\n}\nexport function getEdgeOffset(node, parent, offset) {\n  if (offset === void 0) {\n    offset = {\n      left: 0,\n      top: 0\n    };\n  }\n\n  if (!node || !parent) {\n    return {};\n  } // Get the actual offsetTop / offsetLeft value, no matter how deep the node is nested\n\n\n  var nodeOffset = {\n    left: (offset.left || 0) + node.offsetLeft,\n    top: (offset.top || 0) + node.offsetTop\n  };\n\n  if (node.parentNode === parent) {\n    return nodeOffset;\n  }\n\n  return getEdgeOffset(node.parentNode, parent, nodeOffset);\n}\nexport function getScrollingParent(el) {\n  return closestNode(el, function (el) {\n    var computedStyle = window.getComputedStyle(el);\n    var overflowRegex = /(auto|scroll)/;\n    var properties = ['overflow', 'overflowX', 'overflowY'];\n    return properties.some(function (property) {\n      return overflowRegex.test(computedStyle[property]);\n    });\n  });\n}","map":{"version":3,"names":["INTERACTIVE_ELEMENTS","isContainInteractiveElement","targetNode","includes","tagName","contentEditable","setInlineStyles","node","styles","_i","_Object$entries","Object","entries","length","_Object$entries$_i","key","value","style","setTranslate3d","translate","transform","x","y","setTransitionDuration","duration","transitionDuration","closestNode","sourceNode","judge","currentNode","parentNode","getEdgeOffset","parent","offset","left","top","nodeOffset","offsetLeft","offsetTop","getScrollingParent","el","computedStyle","window","getComputedStyle","overflowRegex","properties","some","property","test"],"sources":["C:/Users/jaink/OneDrive/Desktop/New folder (4)/chameleon-website/node_modules/rsuite/esm/List/helper/utils.js"],"sourcesContent":["/**\n * interactive elements should be skiped\n * */\nvar INTERACTIVE_ELEMENTS = ['A', 'BUTTON', 'INPUT', 'OPTION', 'TEXTAREA', 'SELECT'];\nexport function isContainInteractiveElement(targetNode) {\n  return INTERACTIVE_ELEMENTS.includes(targetNode.tagName) || targetNode.contentEditable === 'true';\n}\nexport function setInlineStyles(node, styles) {\n  if (node !== null && styles !== null) {\n    for (var _i = 0, _Object$entries = Object.entries(styles); _i < _Object$entries.length; _i++) {\n      var _Object$entries$_i = _Object$entries[_i],\n          key = _Object$entries$_i[0],\n          value = _Object$entries$_i[1];\n      node.style[key] = value;\n    }\n  }\n}\nexport function setTranslate3d(node, translate) {\n  setInlineStyles(node, {\n    transform: translate ? \"translate3d(\" + translate.x + \"px,\" + translate.y + \"px,0)\" : ''\n  });\n}\nexport function setTransitionDuration(node, duration) {\n  setInlineStyles(node, {\n    transitionDuration: duration ? duration + \"ms\" : ''\n  });\n}\n/**\n * find closest target node from source node\n * */\n\nexport function closestNode(sourceNode, judge) {\n  var currentNode = sourceNode;\n\n  while (currentNode) {\n    if (judge(currentNode)) {\n      return currentNode;\n    }\n\n    currentNode = currentNode.parentNode;\n  }\n\n  return null;\n}\nexport function getEdgeOffset(node, parent, offset) {\n  if (offset === void 0) {\n    offset = {\n      left: 0,\n      top: 0\n    };\n  }\n\n  if (!node || !parent) {\n    return {};\n  } // Get the actual offsetTop / offsetLeft value, no matter how deep the node is nested\n\n\n  var nodeOffset = {\n    left: (offset.left || 0) + node.offsetLeft,\n    top: (offset.top || 0) + node.offsetTop\n  };\n\n  if (node.parentNode === parent) {\n    return nodeOffset;\n  }\n\n  return getEdgeOffset(node.parentNode, parent, nodeOffset);\n}\nexport function getScrollingParent(el) {\n  return closestNode(el, function (el) {\n    var computedStyle = window.getComputedStyle(el);\n    var overflowRegex = /(auto|scroll)/;\n    var properties = ['overflow', 'overflowX', 'overflowY'];\n    return properties.some(function (property) {\n      return overflowRegex.test(computedStyle[property]);\n    });\n  });\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}