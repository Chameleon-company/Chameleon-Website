{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = defaultOverscanIndicesGetter;\nexports.SCROLL_DIRECTION_VERTICAL = exports.SCROLL_DIRECTION_HORIZONTAL = exports.SCROLL_DIRECTION_FORWARD = exports.SCROLL_DIRECTION_BACKWARD = void 0;\n\nvar _types = require(\"./types\");\n\nvar SCROLL_DIRECTION_BACKWARD = -1;\nexports.SCROLL_DIRECTION_BACKWARD = SCROLL_DIRECTION_BACKWARD;\nvar SCROLL_DIRECTION_FORWARD = 1;\nexports.SCROLL_DIRECTION_FORWARD = SCROLL_DIRECTION_FORWARD;\nvar SCROLL_DIRECTION_HORIZONTAL = 'horizontal';\nexports.SCROLL_DIRECTION_HORIZONTAL = SCROLL_DIRECTION_HORIZONTAL;\nvar SCROLL_DIRECTION_VERTICAL = 'vertical';\n/**\r\n * Calculates the number of cells to overscan before and after a specified range.\r\n * This function ensures that overscanning doesn't exceed the available cells.\r\n */\n\nexports.SCROLL_DIRECTION_VERTICAL = SCROLL_DIRECTION_VERTICAL;\n\nfunction defaultOverscanIndicesGetter(_ref) {\n  var cellCount = _ref.cellCount,\n      overscanCellsCount = _ref.overscanCellsCount,\n      scrollDirection = _ref.scrollDirection,\n      startIndex = _ref.startIndex,\n      stopIndex = _ref.stopIndex; // Make sure we render at least 1 cell extra before and after (except near boundaries)\n  // This is necessary in order to support keyboard navigation (TAB/SHIFT+TAB) in some cases\n  // For more info see issues #625\n\n  overscanCellsCount = Math.max(1, overscanCellsCount);\n\n  if (scrollDirection === SCROLL_DIRECTION_FORWARD) {\n    return {\n      overscanStartIndex: Math.max(0, startIndex - 1),\n      overscanStopIndex: Math.min(cellCount - 1, stopIndex + overscanCellsCount)\n    };\n  } else {\n    return {\n      overscanStartIndex: Math.max(0, startIndex - overscanCellsCount),\n      overscanStopIndex: Math.min(cellCount - 1, stopIndex + 1)\n    };\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","defaultOverscanIndicesGetter","SCROLL_DIRECTION_VERTICAL","SCROLL_DIRECTION_HORIZONTAL","SCROLL_DIRECTION_FORWARD","SCROLL_DIRECTION_BACKWARD","_types","require","_ref","cellCount","overscanCellsCount","scrollDirection","startIndex","stopIndex","Math","max","overscanStartIndex","overscanStopIndex","min"],"sources":["C:/Users/jaink/OneDrive/Desktop/New folder (4)/chameleon-website/node_modules/rsuite/node_modules/react-virtualized/dist/commonjs/Grid/accessibilityOverscanIndicesGetter.js"],"sourcesContent":["\"use strict\";\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports[\"default\"] = defaultOverscanIndicesGetter;\r\nexports.SCROLL_DIRECTION_VERTICAL = exports.SCROLL_DIRECTION_HORIZONTAL = exports.SCROLL_DIRECTION_FORWARD = exports.SCROLL_DIRECTION_BACKWARD = void 0;\r\n\r\nvar _types = require(\"./types\");\r\n\r\nvar SCROLL_DIRECTION_BACKWARD = -1;\r\nexports.SCROLL_DIRECTION_BACKWARD = SCROLL_DIRECTION_BACKWARD;\r\nvar SCROLL_DIRECTION_FORWARD = 1;\r\nexports.SCROLL_DIRECTION_FORWARD = SCROLL_DIRECTION_FORWARD;\r\nvar SCROLL_DIRECTION_HORIZONTAL = 'horizontal';\r\nexports.SCROLL_DIRECTION_HORIZONTAL = SCROLL_DIRECTION_HORIZONTAL;\r\nvar SCROLL_DIRECTION_VERTICAL = 'vertical';\r\n/**\r\n * Calculates the number of cells to overscan before and after a specified range.\r\n * This function ensures that overscanning doesn't exceed the available cells.\r\n */\r\n\r\nexports.SCROLL_DIRECTION_VERTICAL = SCROLL_DIRECTION_VERTICAL;\r\n\r\nfunction defaultOverscanIndicesGetter(_ref) {\r\n  var cellCount = _ref.cellCount,\r\n      overscanCellsCount = _ref.overscanCellsCount,\r\n      scrollDirection = _ref.scrollDirection,\r\n      startIndex = _ref.startIndex,\r\n      stopIndex = _ref.stopIndex;\r\n  // Make sure we render at least 1 cell extra before and after (except near boundaries)\r\n  // This is necessary in order to support keyboard navigation (TAB/SHIFT+TAB) in some cases\r\n  // For more info see issues #625\r\n  overscanCellsCount = Math.max(1, overscanCellsCount);\r\n\r\n  if (scrollDirection === SCROLL_DIRECTION_FORWARD) {\r\n    return {\r\n      overscanStartIndex: Math.max(0, startIndex - 1),\r\n      overscanStopIndex: Math.min(cellCount - 1, stopIndex + overscanCellsCount)\r\n    };\r\n  } else {\r\n    return {\r\n      overscanStartIndex: Math.max(0, startIndex - overscanCellsCount),\r\n      overscanStopIndex: Math.min(cellCount - 1, stopIndex + 1)\r\n    };\r\n  }\r\n}"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAC3CC,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAAC,SAAD,CAAP,GAAqBE,4BAArB;AACAF,OAAO,CAACG,yBAAR,GAAoCH,OAAO,CAACI,2BAAR,GAAsCJ,OAAO,CAACK,wBAAR,GAAmCL,OAAO,CAACM,yBAAR,GAAoC,KAAK,CAAtJ;;AAEA,IAAIC,MAAM,GAAGC,OAAO,CAAC,SAAD,CAApB;;AAEA,IAAIF,yBAAyB,GAAG,CAAC,CAAjC;AACAN,OAAO,CAACM,yBAAR,GAAoCA,yBAApC;AACA,IAAID,wBAAwB,GAAG,CAA/B;AACAL,OAAO,CAACK,wBAAR,GAAmCA,wBAAnC;AACA,IAAID,2BAA2B,GAAG,YAAlC;AACAJ,OAAO,CAACI,2BAAR,GAAsCA,2BAAtC;AACA,IAAID,yBAAyB,GAAG,UAAhC;AACA;AACA;AACA;AACA;;AAEAH,OAAO,CAACG,yBAAR,GAAoCA,yBAApC;;AAEA,SAASD,4BAAT,CAAsCO,IAAtC,EAA4C;EAC1C,IAAIC,SAAS,GAAGD,IAAI,CAACC,SAArB;EAAA,IACIC,kBAAkB,GAAGF,IAAI,CAACE,kBAD9B;EAAA,IAEIC,eAAe,GAAGH,IAAI,CAACG,eAF3B;EAAA,IAGIC,UAAU,GAAGJ,IAAI,CAACI,UAHtB;EAAA,IAIIC,SAAS,GAAGL,IAAI,CAACK,SAJrB,CAD0C,CAM1C;EACA;EACA;;EACAH,kBAAkB,GAAGI,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYL,kBAAZ,CAArB;;EAEA,IAAIC,eAAe,KAAKP,wBAAxB,EAAkD;IAChD,OAAO;MACLY,kBAAkB,EAAEF,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYH,UAAU,GAAG,CAAzB,CADf;MAELK,iBAAiB,EAAEH,IAAI,CAACI,GAAL,CAAST,SAAS,GAAG,CAArB,EAAwBI,SAAS,GAAGH,kBAApC;IAFd,CAAP;EAID,CALD,MAKO;IACL,OAAO;MACLM,kBAAkB,EAAEF,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYH,UAAU,GAAGF,kBAAzB,CADf;MAELO,iBAAiB,EAAEH,IAAI,CAACI,GAAL,CAAST,SAAS,GAAG,CAArB,EAAwBI,SAAS,GAAG,CAApC;IAFd,CAAP;EAID;AACF"},"metadata":{},"sourceType":"script"}